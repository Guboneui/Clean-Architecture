# 컴포넌트
컴포넌트: 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위. Swift의 경우 .ipa 파일이 컴포넌트이다. 또한 컴포넌트는 컴파일형 언어에서 바이너리 파일의 겹합체다. 이때 Swift는 컴파일형 언어이다.

여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있고, 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다. 

---

# 컴포넌트 응집도
어떤 클래스를 어느 컴포넌트에 포함시켜야 하는지는 중요한 부분이다. 이를 충족하기 위해 3가지 원칙을 논의해야 한다. 

**[REP: 재사용/릴리스 등가 원리 - Reuse/Release Equivalence Principle]**

`재사용 단위는 릴리스 단위와 같다.`

새로운 버전이 언제 출시되고 무엇이 변했는지를 개발자들이 알아야한다. 따라서 릴리스 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다. 해당 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다. 즉, 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.

하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.

**[CCP: 공통 폐쇄 원칙 - Common Closure Principle]**

`동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라`

CCP는 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 것이다. 즉, 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다. 

대다수 앱에서 `유지보수성`은 재사용성보다 중요하다. 코다가 변경되어야 한다면, 여러 컴포넌트 도처에 분산되어 발생하기보다, 변경 모두가 단일 컴포넌트에서 발생하는 편이 좋다. OCP와 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권장한다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.

CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP의 교훈을 확대 적용한다. 따라서 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다. 

SRP에서는 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라고 말한다. CCP에서는 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라고 말한다.

즉, **동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라, 서로 다른 시점에 서로 다른 이유로 변경되는 것들은 서로 분리하라.**

**[CRP: 공통 재사용 원칙 - Common Reuse Principle]**

`컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라`

공통 재사용 원칙도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다. 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다. 개별 클래스가 단독으로 재사용되는 경우는 거의 없다. 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용 하는 경우가 많다. 

하지만, CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다. 

어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 `의존성`이 생겨난다. 이 의존으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높으며, 사용하는 컴포넌트를 변경하지 않더라도 재검증, 재배포, 재컴파일 해야 하는 가능성은 남아있다. 

즉, CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다. 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.

이를 기반으로 CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다. ISP에서 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언했다면, CRP에서는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.

---

REP와 CCP는 `포함 원칙`이다. 두 원칙은 컴포넌트를 더욱 크게 만든다. 하지만 CRP는 `배제 원칙`이며 컴포넌트를 더욱 작게 만든다. 따라서 이 원칙들이 균형을 이루는 방법을 찾아야 한다. 

`결합도 원칙들의 균형 다이어그램`
![image](https://user-images.githubusercontent.com/73548875/233786443-122512bc-2919-4a27-9999-9a3fd215f3f4.png)

- REP와 CRP에만 중점을 둔다면, 컴포넌트 변경이 너무 빈번하게 일어난다.
- CCP와 REP에 중점을 둔다면, 불필요한 릴리스가 너무 빈번하다.
- CCP와 CRP에 중점을 둔다면, 재사용이 어려워 진다.

**세 가지 원칙을 통해, 어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다.**

---

# 컴포넌트 결합

[ADP: 의존성 비순환 원칙]

`컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.`

순환이 생기는 각 컴포넌트들은 결국 하나의 거대한 컴포넌트가 된다. 또한, 순환으로 인해 어떤 순서로 빌드해야 올바를지 파악하기가 힘들다.

이러한 의존성 순환을 해결하기 위해 아래와 같은 방법을 이용한다. 

`의존성 역전 원칙(DIP)을 적용한다.`

인터페이스(protocol)을 통해 의존성을 역전시키면, 순환을 끊을 수 있다. 이후 두 컴포넌트가 모두 의존하는 새로운 컴포넌트를 만든 후, 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다. 

[SDP: 안정된 의존성 원칙]

`안정성의 방향으로(더 안정된 쪽에) 의존하라`

설계는 정적일 수 없으며, 변경은 불가피하다. 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만든다면, 변동성이 큰 컴포넌트도 결국 변경이 어려워진다. 

수 많은 컴포넌트가 특정 컴포넌트에 의존하게 만든다면, 다시 말해 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 반경하려면 상당한 노력이 들기 때문이다. 

`A->X`, `B->X`, `C->X`라고 한다면 X는 안정된 컴포넌트다. 세 컴포넌트가 X에 의존하며, X 는 변경하지 말아야 할 이유가 세 가지나 되기 때문이다. 이 경우 X 컴포넌트는 세 가지 컴포넌트를 `책임진다`라고 말 할 수 있다. 반대로 X는 어디에도 의존하지 않으며 X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다. 따라서 X는 독립적이다. 

반대로 `Y->A`, `Y->B`, `Y->C`라고 한다면 Y는 상당히 불안정한 컴포넌트다. 어떤 컴포넌트도 Y에 의존하지 않으므로 Y는 책임성이 없다. 또한 Y는 세 개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 세 가지다. 따라서 Y는 의존적이다.


[SAP: 안정된 추상화 원칙]

`컴포넌트는 안정된 정도만큼만 추상화되어야 한다.`

시스템에서는 고수준 아키텍처나 정책 결정과 관련된 소프트웨어 처럼 자주 변경해서는 절대로 안 되는 소프트웨어도 있다. 따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 하며, 불안정한 컴포넌트는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다. 

만약 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기가 어려워 지며, 결국 유연성을 잃게 된다. 

안정된 추상화 원칙은 `안정성`과 `추상화 정도` 사이의 관계를 정의한다. 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다. 또한 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 하며 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 한다. 

따라서, 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다. `안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.`






