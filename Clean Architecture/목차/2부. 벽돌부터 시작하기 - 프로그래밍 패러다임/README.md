# 패러다임 개요

구조적 프로그래밍: 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
객체 지향 프로그래밍: 제어흐름의 간접적인 전화에 대해 규칙을 부과한다.
함수형 프로그래밍: 할당문에 대해 규칙을 부과한다.

**각 패러다임은 권한을 박탈하며, 어느 패러다임도 새로운 권한을 부여하지 않는다. 각각은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과하며 무엇을 해야 할지를 말하기 보다는 무엇을 해서는 안 되는지를 말한다**

아키텍처 경계를 넘나들기 위한 메커니즘으로 **다형성**을 이용하며, 함수형 프로그래밍을 이용해 데이터의 위치와 접근 방법에 대해 **규칙**을 부과한다. 또한 **모듈**의 기반 알고리즘으로 구조적 프로그래밍을 사용한다.

위의 패러다임과 아키텍처의 세 가지 큰 관심사인 '함수', '컴포넌트 분리', '데이터 관리'가 어떻게 서로 연과되는지 확인해야 할 필요가 있다. 

---

# 구조적 프로그래밍

**모듈을 증명 가능하게 하는 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다**.

순차구문: 열거법을 통해 올바름을 입증할 수 있다. 순차 구문의 입력을 출력까지 수학적으로 추적한다.
분기구문: 분기를 통해 각 경로를 결거한 후, 두 경로가 수학적으로 적절한 결과를 만들어 낸다면 증명 가능하다.
반복구문: 귀납법을 통해 증명 가능하다. 1의 경우가 올바르고, N의 경우도 올바르다면, N+1의 경우도 올바르다.

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 잔위로 재귀적으로 분해할 수 있으며, 이는 모듈을 기능적으로 분해할 수 있음을 뜻한다.

테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수 없다. 즉, 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다. 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한 후, 테스트를 통해 증명 가능한 세부 기능들이 거짓인지 증명하려고 시도한다.
거짓임을 증명하려는 테스트가 실패한다면, 목표에 부합할 만큼은 충분히 참이라고 생각할 수 있다. 

아키텍처의 관점에서 **기능적 분해**를 최고의 실천법 중 하나로 여긴다.
가장 작은 기능부터 가장 큰 컴포넌트까지 모든 수준에서 소프트웨어는 반증 가능성에 의해 주도된다. 따라서 **소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록, 즉 테스트가 쉽도록 만들기 위해 노력해야 한다**.

---

# 객체 지향 프로그래밍

일반적으로 좋은 아키텍처란 '객체 지향 👻👻 설계 원칙'을 이해하고 응용하는데서 출반한다. 👻👻의 본질을 설명하기 위해서는 '캡슐화', '상속', '다형성'의 개념을 적절하게 조합한 것이다.

캡슐화: 캡슐화를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 이는 private 멤버 데이터와 public 멤버 함수로 표현된다.
상속: 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다. 
다형성: 제어흐름을 간접적으로 전환하는 규칙

다형성의 장점
요구사항이 변경되었을 때 기존 프로그램에서 상당히 많은 부분을 재작성하지 않고 'A' 'B'에 관계없이 동일한 프로그램을 사용할 수 있다.

의존성 역전
전형적인 호출 트리의 경우 main함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하며, 중간 수준 함수는 다시 저수는 함수를 호출한다. 이에 아래와 같은 소스코드 의존성과 제어흐름을 가진다.

![IMG_0211](https://user-images.githubusercontent.com/73548875/233061103-f4daa13c-ba89-40e1-b656-2c8cc6bb2efc.jpeg)

하지만, 다형성을 사용한다면 소스 코드에서는 HL1 모듈은 인터페이스(swift에서는 protocol)을 통해 F()함수를 호출한다. 이 인터페이스는 런타임에는 존재하지 않은다. HL1은 단순히 ML1 모듈의 함수 F()를 호출할 뿐이다. 예시는 아래와 같다.
![IMG_0212](https://user-images.githubusercontent.com/73548875/233061132-7dad96a0-ec28-4a97-a2b4-8ab0a578b0f3.jpeg)

이처럼 다형성을 이용하면 소스 코드 의존성(상속 관계)이 제어흐름과는 반대가 된다. 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.

👻👻는 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획들할 수 있다. 👻👻를 이용한다면 플러그인 아키텍처(swift에서 import)를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플로그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

---

# 함수형 프로그래밍

함수형 프로그래밍의 기본은 불변성이다. 아래 코드는 명령형 프로그래밍 스타일로 i가 변하게 된다. 이때 i를 '가변 변수'라고 한다. 
```
for i in 0..<25 {
  print(i)
}
```

하지만 함수형 프로그래밍을 사용하게 된다면 가변변수는 존재하지 않는다. 아래 코드에서 num은 변경 불가능 하다.
```
let arr: [Int] = Array(0..<25)
arr.forEach { num in
  print(num * num)
}

Thread를 고려할 때, 경합조건(race), 교착상태(deadLock), 동시 업데이트(concurrent update) 문제는 모두 가변 변수로 인해 발생한다. 앱의 동시성 즉, 다수의 쓰레드와 프로세스를 사용하는 앱에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다. 이에 동시성(concurrent)문제에 관심을 가져야 한다.

불변성과 관련하여 '가변 컴포넌트'와 '불변 컴포넌트'를 분리하는 일이다. 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 

상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 원인이 되며, 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.(Sendable..?)

---

결론적으로 소프트웨어, 컴퓨터 프로그램은 '순차', '분기', '반복', '참조' 그 이상도 이하도 아니다.

출처: Clean Arhitecture 
